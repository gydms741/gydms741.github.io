---
title: "@Transactional"
date: 2022-01-13 23:33:28 -0400
categories: spring
---

## Transaction이란?

- 데이터베이스 연산들의 논리적 단위이며 트랜잭션 내 모든 연산들이 정상적으로 완료되지 않으면 아무 것도 수행되지 않은 원래 상태로 복원되어야 함.
- 데이터베이스의 상태를 변경시키는 작업 또는 한번에 수행되어야하는 연산들을 의미.
- ex) 친구에게 인터넷 뱅킹으로 10,000원을 송금
나의 통장 = -10,000원
친구 통장 = +10,000원
이 결과로 나와야하지만 알 수 없는 오류로 인해 나의 계좌에서는 돈이 나갔지만 친구는 받지 못한 상황.
10,000원은 증발. ⇒ 이런 현상을 방지하기 위해 transaction처리를 해줘야 함. rollback으로 데이터 정합성을 맞춰줌.
- 위와 같은 과정을 트랜잭션이라 볼 수 있으며, 데이터베이스 연산들의 논리적 단위라고 할 수 있다.

### Transaction의 성질

- 원자성(Atomicity)
    
    한 트랜잭션 내에서 실행한 작업들은 하나로 간주한다. 즉, 모두 성공 또는 모두 실패.
    
- 일관성(Consistency)
    
    트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다. (data integrity 만족 등)
    
- 격리성(Isolation)
    
    동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야 한다.
    
- 지속성(Durability)
    
    트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.
    

## Transaction을 처리하다 자주 발생하게 되는 상황

- 트랜잭션 동작 도중 다른 트랜잭션을 호출(실행)하는 상황. 
피호출 트랜잭션의 입장에서는 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있음 ⇒ 중간에 오류 발생한 경우 모든 트랜잭션 롤백
새롭게 트랜잭션 생성할 수도 있음 ⇒ 오류가 발생한 트랜잭션이 롤백 됨
:: 이런 트랜잭션 관련 설정은 propagation 속성을 통해 지정 가능함. 
1. REQUIRE_NEW : 현재 진행중인 트랜잭션이 있으면 그것을 사용하고, 없으면 생성[DEFAULT 값]
2. MANDATORY : 현재 진행중인 트랜잭션이 없으면 Exception 발생. 없으면 생성
3. REQUIRES_NEW : 항상 새로운 트랜잭션 만듦(트랜잭션 분리)
4. SUPPORTS : 현재 진행중인 트랜잭션이 있으면 그것을 사용. 없으면 그냥 진행
5. NOT_SUPPORTED : 현재 진행중인 트랜잭션이 있으면 그것을 미사용. 없으면 그냥 진행
6. NEVER : 현재 진행중인 트랜잭션이 있으면 Exception. 없으면 그냥 진행
- Problem1 - Dirty Read
- 트랜잭션 A가 어떤 값을 1에서 2로 변경하고 아직 커밋하지 않은 상황에서 트랜잭션 B가 같은 값을 읽는 경우 트랜잭션 B는 2가 조회된다.
- 트랜잭션 B가 2를 조회한 후 혹시 A가 롤백되면 결국 트랜잭션 B는 잘못된 값을 읽게 된 것. 즉, 아직 트랜잭션이 완료되지 않은 상황에서 데이터에 접근을 허용할 경우 발생할 수 있는 데이터 불일치이다.
- problem2 - Non-Repeatable Read
- 트랜잭션 A가 어떤 값 1을 읽었다. 이후 A는 같은 쿼리를 또 실행할 예정인데, 그 사이에 트랜잭션 B가 값 1을 2로 바꾸고 커밋해버리면 A가 같은 쿼리 두번을 날리는 사이 두 쿼리의 결과가 다르게 되어 버린다.
- 즉, 한 트랜잭션에서 같은 쿼리를 두번 실행했을 때 발생할 수 있는 데이터 불일치이다. 
Dirty Read에 비해서는 발생 확률이 적다.
- problem3 - Phantom Read
- 트랜잭션 A가 어떤 조건을 사용하여 특정 범위의 값들 [0,1,2,3,4]를 읽었다.

## @Transactional 옵션

- propagation : 트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 지정하는 옵션
- isolation : 트랜잭션에서 일관성 없는 데이터 허용 수준을 설정한다.
- noRollbackFor=Exception.class : 특정 예외 발생 시 rollback 하지 않는다.
- noRollbackFor=Exception.class : 특정 예외 발생 시 rollback 한다.
- timeout : 지정한 시간 내에 메소드 수행이 완료되지 않으면 rollback 한다.
- readOnly : 읽기 전용

## @Transactional이 적용되어 있을 경우

- 클래스에 적용된 경우 : 트랜잭션 기능이 적용된 프록시 객체가 생성된다. 이 프록시 객체는 @Transactional이 포함된 메소드가 호출 될 경우, PlatformTransactionManager를 사용하여 트랜잭션을 시작하고, 정상 여부에 따라 Commit 또는 Rollback 한다.

## Transaction 주의 사항

> 트랜잭션은 꼭 필요한 최소한의 범위로 수행해야 한다. 왜냐하면 일반적으로 데이터베이스 커넥션은 갯수가 제한적이기 때문에 각 트랜잭션에서 커넥션을 소유하는 시간이 길어진다면, 그 이후에 사용 가능한 커넥션의 갯수가 줄어든다. 그러다 어느 순간 다른 트랜잭션이 수행될 때, 커넥션이 부족하여 받기 위해 기다리는 상황이 발생할 수 있다.
> 

## Questions

- @Trancsactional 사용을 클래스에서 한번 선언하고 클래스 안 메소드 내에서도 한번 더 선언하는데 그 이유가 뭘까? 
- Class 에 선언적 트랜잭션을 적용할 경우, 각 메소드마다 transaction이 적용이 된다. 그런데 굳이 클래스에 선언을 하고 메소드에서도 적용을 하려하는 이유가 뭘까....? transaction이 적용되는 우선순위를 알아보자. 
- 적용되는 우선순위 : 클래스 메소드 ⇒ 클래스 ⇒ 인터페이스 메소드 ⇒ 인터페이스
- 왜 우선 적용하려는걸까? 
- 추측 : 메소드 내에서 우선적으로 찾는다면, 클래스 전체에서 찾는 수고로움을 덜 수 있어서?? 
- 모든 db 트랜잭션은 격리수준을 가지고 있어야 한다. 서버 환경에서는 여러 개의 트랜잭션이 동시에 진행될 수 있기 때문. 순차적으로 진행되어 독립적이면 좋겠지만 성능이 크게 떨어질 수 밖에 없음. 따라서, 적절하게 격리수준을 조정해 가능한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어가 필요함.
- 트랜잭션이 일부 메서드에서 필요없는 경우가 있을 수 있다. 
그럴 경우는 @Transactional(propagation = Propagation.NEVER) 을 메소드에 지정하면 트랜잭션이 시작되지 않고 동작한다.
- noRollbackFor를 사용하는 이유? 
- 때에 따라서 특정 트랜잭션은 rollback이 일어나지 않도록 하고 싶을 수도 있는데, 이 때 noRollbackFor라는 속성을 사용할 수 있다. 
⇒ 그렇다면 여기서 또 궁금한 점. 애초에 rollback이라는 이점을 사용하기 위해 transaction처리를 하는게 아니였나? 트랜잭션이란 데이터베이스의 상태를 변경시키는 작업 또는 한번에 수행되어야하는 연산들을 의미한다. 트랜잭션 작업이 끝나면 Commit또는 Rollbaack 되어야 한다. 
- noRollbackFor 속성에 정의한 Exception이 해당 트랜잭션 내부에서 발생할 경우, 진행한 부분까지 commit이 일어나며 rollback을 진행하지 않는다. 한 번에 여러 개의 Exception을 명시할 수 있고, 해당 Exception class는 Throwable의 서브클래스여야 한다. 라고 나와있는데 이해가 되지 않는다..ㅎㅎ

이건 이해가 될 때까지 지속적으로 복기하며, 차후 수정해 나가야겠다. 
